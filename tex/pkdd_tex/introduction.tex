\section{Introduction}
\label{introduction}

Graphs are naturally used to model many real-world networks, \eg online social networks, biological networks, collaboration and communication networks. As community structures are commonly found in real-world networks, community related problems have been widely studied in the literature, such as community detection (\cite{newman2004finding, xie2013overlapping}) and community search (\cite{huang2014querying, akbas2017truss, huang2015approximate, lee2016query, sozio2010community, cui2014local, li2015influential, barbieri2015efficient}), and have found a wide range of applications (\cite{durmaz2017frequent,zong2015behavior,yin2017taming}). Triangles are known as fundamental building blocks of networks. K-truss as a definition of cohesive subgraph based on triangles of a graph, requires that each edge be contained in at least $(k - 2)$ triangles within this subgraph. The low computation cost of k-truss makes it suitable to scale to large-scale graphs.
The original definition of a k-truss lacks the connectivity constraint so that a k-truss may be an unconnected subgraph. \cite{huang2014querying} introduce the model of k-truss community based on triangle connectivity.

Community search, a query-dependent variant of community detection, attracts more attention as it enables targeted community discovery around given seed vertices of interest and is faster to process in the sense that the runtime does not depend on the size of the graph. However, all the relevant communities still have to be exhaustively identified, leading to excessive computation time/space if details of communities are not of interest. There are various types of queries that are useful in real-world applications involving communities that do not require details of communities. 
%The local community queries, such as community search, 
We can classify local community queries, such as community search, into two categories according to the level of information required to answer a query, the \toplevelprob{} query and the \bottomlevelprob{} query. The \toplevelprob{} query requires only relation information between different communities of interest. For example, "Do query vertices belongs to the same communities?", "What is the level of cohesiveness among all query vertices?". It is possible to process this type of queries by only examining relations between relavant communities to which query vertices belong without diving into inside structures of them. Another type of queries, the \bottomlevelprob{} query, requires edge level information to process, for example, the widely studied community search problem or finding boundaries of a target community. One has to know edge level structures inside relevant communities to be able to answer such queries.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{./figures/illustration_main.png}
    \caption{Two layer index structure for k-truss community queries.}
    \label{fig:illustration_main}
		\vspace{-0.2 in}
\end{figure}

Local community queries, such as community search, based on the k-truss community model (\cite{huang2014querying}) can benefit from compact index structures constructed from pre-computed results due to the low computational cost of the k-truss community model. Previous works mainly focused on community search problem of a single query vertex (\cite{huang2014querying, akbas2017truss}). In this paper, we propose a novel 2-level index structure, to support both the \toplevelprob{} and the \bottomlevelprob{} k-truss community query. An overview of our \twolevelindex{} is shown in \autoref{fig:illustration_main}. The top level index is a super-graph with vertices represent unique k-truss communities and edges represent containment relations between k-truss communities. For the bottom level index, We introduce a new type of graph called triangle derived graph that translates triangle connectivity in a graph to edge connectivity for fast k-truss community traversal. We store a maximum spanning forest of the triangle derived graph generated from the underlying graph that preserves the detailed edge level structure of k-truss communities in the bottom level index. 
%We combine the top level index and bottom level index together by partition the bottom level index based on 
%We partitioned this maximum spanning tree according to k-truss communities and the subgraph belonging to each k-truss community separatel. 
The super-graph forms a forest, and we can use simple $union$ and $intersection$ operations to locate relevant k-truss communities of a given query. 
To handle local k-truss community queries, we can use simple $union$ and $intersection$ operations on the top level index to efficiently locate target communities of a query. These communities can be used to answer \toplevelprob{} queries directly or handed to the bottom level index to processing inner-community details for \bottomlevelprob{} queries. The bottom level index is only used for \bottomlevelprob{} queries that using edge level information to further process relevant communities provided by the top level index. For example, in a community search query, we can first use the top level index to find target k-truss communities that contain all query vertices and then use the bottom level index to retrieve edges contained in each target k-truss community. The \twolevelindex{} proposed in this paper can efficiently process both single-vertex queries and multiple-vertex queries. We proved our index and query process to be theoretically optimal and showed its efficiency in practice for both \toplevelprob{} and \bottomlevelprob{} k-truss community queries on real-world graphs and demonstrate its performance by comparing with state-of-the-art methods, the TCP index (\cite{huang2014querying}) and the Equitruss index (\cite{akbas2017truss}). For reproducibility, we make the source code available online.\footnote{https://github.com/DongCiLu/KTruss1 34}

Our contribution can be summarized as follows.
\begin{itemize}
	\item We categorize the local k-truss community queries into the \toplevelprob{} query and the \bottomlevelprob{} query based on the information required to answer each type of query. 
	%which is supported by various query types. The k-truss community identity search is efficient for many real-world applications and is much more efficient than k-truss community search based approach.
	\item We develop a 2-level index structure that can efficiently process both the \toplevelprob{} and the \bottomlevelprob{} k-truss community query. The top level index contains a super-graph for locating target communities of a given query. The bottom level index preserves the edge level triangle connectivity for detailed search of inner-community structures.  
	%\item We design an efficient bottom-up index construction algorithm for our 2-level index structure. The time and space complexity is $O(m\log{m})$ and $O(m)$ respectively.
	\item We perform extensive experiments on our 2-level index on large-scale real-world graphs and compare it with state-of-the-art index structures. We can process \toplevelprob{} queries in the range of hundreds of microseconds to less than a second. We can process \bottomlevelprob{} queries in the range of few seconds to hundreds of seconds for highest degree vertices within large communities. %Our index The results show that our index is not only much compact and efficient for k-truss community search queries but can also support various query types.
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{preliminary} provides notations and definitions used in this paper. We design a novel 2-level index structure in Section~\ref{index}. Section~\ref{query} discusses the query process on the proposed index structure. The evaluations of our algorithm are in Section~\ref{evaluation}.  We discuss previous works in Section~\ref{relatedwork} and conclude our work in Section~\ref{conclusion}.

