\section{Introduction}
\label{introduction}

Online social networks have seen rapid growth in recent years and have generated massive data, which has attracted much research effort on developing advanced data mining technologies \cite{cohen2008trusses, liu2018connect, wang2017big, wu2018social, lu2017decentralized}. Graphs are naturally used to model real-world networks such as social networks. A well-studied graph problem, known as community search \cite{huang2014querying, akbas2017truss, sozio2010community, cui2014local}, is to find communities with a query vertex and a specific cohesiveness measure. 
The normal procedure of community search involves making an exhaustive discovery of all the relevant communities, \ie enumerating all the edges in each community, which leads to excessive computation time/space when edge-level details of communities are not pertinent. %There are various types of queries that are useful in real-world applications involving communities that do not require details of communities. 
For example, if one wants to use the cohesiveness of common communities among a set of vertices as a similarity measure, it is not necessary to discover all the edges in common communities. The identifiers of common communities and the cached statistics of each community, \eg cohesiveness measure and size, are sufficient. As such, we can generalize the concept of community search to local community queries, which are meant to identify common communities among a set of query vertices given the cohesiveness criteria. Depending on application requirements, local community queries may or may not search the edge-level details of each relevant community. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\linewidth]{./figures/illustration_main.png}
		\vspace{-0.2cm}
    \caption{Two-level index structure for k-truss community queries. The top-level index is a super-graph which represents k-truss communities and their containment relations. The bottom-level index is a maximum spanning forest of the\inducedgraph{} that preserves triangle connectivity.}
    \label{fig:illustration_main}
		\vspace{-0.5cm}
\end{figure}

To get a better idea, let's consider an example application of team formation. We have a number of skilled workers and we want to pick some of these workers to form a team to achieve a certain goal. It is desirable to pick workers that share common interests or are well acquainted so that they can work well together to help achieve the goal. For this type of problem, if we use graph to model the underlying social network and use graph communities to model common interests, all we want to know is whether a set of vertices (workers) belong to some common communities and the cohesiveness of such communities. We are not interest in who else is in those common communities. Similar applications include user similarity (if we use graph community to model similarity among users), tag suggestion (if we use graph communities to model photo tags), etc. We refer to local community queries that do not require edge-level details as \toplevelprob{} queries. An application might also require the details regarding exactly which edges belong to relevant communities, such as classic community search queries. We refer to those queries as \bottomlevelprob{} queries.
%In this paper we study a more generalized problem. Given a set of query vertices and user-defined cohesiveness criteria, we want to find community-level relations among all query vertices with or without edge-level details. 
%We refer to this problem as local community query because it is query-dependent and the runtime does not rely on the size of the graph. 
%As the community query reveals the community-level relations for a group of vertices, it can be used as a building block for many analytical tasks, such as similarity measurement \cite{tsitsulin2018verse}, social recommendation \cite{liu2018connect}, and de-anonymization \cite{wu2018social}.



%In this paper, we adopt k-truss community as the community model. K-truss, as a definition of a cohesive subgraph, requires each edge to be contained in at least $k - 2$ triangles. The k-truss community model based on triangle connectivity, which ensures the connectivity inside the community, is introduced by \cite{huang2014querying}. The bounded diameter property of a k-truss community makes it an excellent choice for discovering cohesive and meaningful communities. The low computation cost of k-truss helps in the scaling of large graphs.

In this paper, we adopt the k-truss community model based on triangle connectivity introduced by \cite{huang2014querying}.
%Local community queries can benefit from compact index structures constructed from pre-computed results. 
Previous works were mainly focused on the community search problem of a single query vertex \cite{huang2014querying, akbas2017truss}. In this paper, we propose a novel two-level index structure to support both the \toplevelprob{} and the \bottomlevelprob{} local k-truss community queries of a set of query vertices. An overview of our \twolevelindex{} is shown in \autoref{fig:illustration_main}. The top-level index is a super-graph whose vertices represent unique k-truss communities and whose edges represent the containment relations between them. For the bottom-level index, we introduce a new type of graph called triangle-derived graph that translates triangle connectivity to edge connectivity for fast k-truss community traversal. We can use simple $union$ and $intersection$ operations on the top-level index to locate relevant k-truss communities in a given query, in order to answer \toplevelprob{} queries directly. Once the identifiers of relevant communities are found, they can be handed to the bottom-level index to easily answer \bottomlevelprob{} queries.
%For example, given a community search query, we first use the top-level index to find target k-truss communities that contain all query vertices and then use the bottom-level index to retrieve the edges contained in each target k-truss community without expensive triangle enumerations. 

Our index also supports queries with arbitrary cohesiveness criteria. Previous works required a specific cohesiveness measurement, \eg a specific $k$, to process a query. However, in reality such criteria may not be available. For example, if we want to know the common interests among a set of users, what is a good guess of cohesiveness measure, /ie $k$ in k-truss community model, to start with? More practical queries are searching for communities that contain the query vertices regardless of their cohesiveness, or searching for communities that contain the query vertices with highest possible cohesiveness.

%We prove our index and query process to be theoretically optimal, show its practical efficiency for various types of \toplevelprob{} and \bottomlevelprob{} local k-truss community queries on real-world graphs and demonstrate its performance by comparing with state-of-the-art methods, the TCP index \cite{huang2014querying} and the Equitruss index \cite{akbas2017truss}. For reproducibility, we make the source code available online (https://github.com/DongCiLu/KTruss).

Our contribution can be summarized as follows.
\begin{itemize}
	\item We generalize the community search problem into the local community query problem. The generalization comprises three aspects. First, we introduce both \toplevelprob{} and \bottomlevelprob{} queries that provide different level of information for relevant communities. For applications that only require community-level information such as team formation or tag suggestion, processing \toplevelprob{} instead of \bottomlevelprob{} can avoid a large amount of redundant computation. Second, we support multiple query vertices to enable applications that require community relation among query vertices. Third, we incorporate various cohesiveness criteria instead of a single cohesiveness measurement. Especially, we support queries with non-specific cohesiveness criteria, such as maximum possible cohesiveness or arbitrary cohesiveness, which is quite useful in applications.
	\item We develop a \twolevelindex{} structure that can efficiently process both the \toplevelprob{} and the \bottomlevelprob{} k-truss community query for a single query vertex or a set of query vertices with any given cohesiveness criteria, using an efficient two step process. We proved our \twolevelindex{} is theoretical optimal for both \toplevelprob{} and \bottomlevelprob{} queries.
	\item We perform extensive experiments on our \twolevelindex{} for large-scale real-world graphs and compare our index structure with the state-of-the-art index structures, Equitruss and TCP-Index. Experimental results show that \twolevelindex{} outperforms the state-of-the-art solutions on community search query and is an order of magnitude faster on \toplevelprob{} query.  
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{preliminary} provides notations and definitions. We design the index structure and its query process in Section~\ref{index}. The evaluations are in Section~\ref{evaluation}. We discuss previous works in Section~\ref{relatedwork} and conclude our work in Section~\ref{conclusion}.

