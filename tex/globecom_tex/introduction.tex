\section{Introduction}
\label{introduction}

Graphs are naturally used to model many real-world networks, \eg online social networks, biological networks, collaboration and communication networks. A well studied graph problem, which is called community search \cite{huang2014querying, akbas2017truss, huang2015approximate, lee2016query, sozio2010community, cui2014local, li2015influential, barbieri2015efficient}, is to find communities with a query vertex and a specific cohesiveness measure. In this paper we are studying a related but more generalized problem. Given a set of query vertices and user defined cohesiveness criteria, find communities that both meet cohesiveness criteria and containing all query vertices. We refer to this problem as local community query because it is query-dependent and the runtime does not rely on the size of the graph. As the community query reveals the community-level relations for a group of vertices, it can be used as a building block for many analytical tasks, such as similarity measurement \cite{tsitsulin2018verse}, 
%node classification \cite{henderson2011s}, 
social recommendation \cite{liu2018connect}, de-anonymization \cite{wu2018social}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\linewidth]{./figures/illustration_main.png}
    \caption{Two layer index structure for k-truss community queries. The top level index is a super-graph with vertices representing unique k-truss communities and edges representing containment relations between them. The bottom level index is triangle derived graph that translates triangle connectivity in the underlying graph to edge connectivity for fast k-truss community traversal.}
    \label{fig:illustration_main}
		%\vspace{-0.2 in}
\end{figure}

The normal procedure of community search involves exhaustively discover all the relevant communities, \ie, enumerate all the edges in each community, leading to excessive computation time/space if edge-level details of communities are not of interest. %There are various types of queries that are useful in real-world applications involving communities that do not require details of communities. 
For example, if one want to use the cohesiveness of common communities among a set of vertices as a similarity measure, it is not necessary to discover all edges in common comminities. Identifiers of common communities and cached statistics of each community, \eg, cohesiveness measure and size, are sufficient. As such, we can generalize the concept of community search to local community queries, which is to identify common communities among a set of query vertices given cohesiveness creteria. Local community queries may or may not search the edge-level details of each relevant community according to application requirements. To get a better idea, consider the example query "Given a set of query vertices, do they belong to same communities?" This type of query does not require edge-level details of communities and is good for applications such as studying common interests among a set of users. We refer to local community queries that do not require edge-level details as \toplevelprob{} queries. It is also possible that an application require the details of exactly which edges belong to relevant communities, such as classic community search queries. We refer to those queries as \bottomlevelprob{} queries.

To study local community queries, we adopt K-truss community as the community model. K-truss as a definition of cohesive subgraph, requires that each edge be contained in at least $(k - 2)$ triangles within this subgraph. \cite{huang2014querying} introduce the model of k-truss community based on triangle connectivity that ensures the connectivity inside the community. The bounded diameter property of a K-truss community makes it an excellent choice for discovering cohesive and meaningful communities. The low computation cost of k-truss helps to scale to large-scale graphs.

Local community queries can benefit from compact index structures constructed from pre-computed results. Previous works mainly focused on the community search problem of a single query vertex \cite{huang2014querying, akbas2017truss}. In this paper, we propose a novel 2-level index structure, to support both the \toplevelprob{} and the \bottomlevelprob{} k-truss community query. An overview of our \twolevelindex{} is shown in \autoref{fig:illustration_main}. The top level index is a super-graph with vertices representing unique k-truss communities and edges representing containment relations between them. For the bottom level index, we introduce a new type of graph called triangle derived graph that translates triangle connectivity in a graph to edge connectivity for fast k-truss community traversal. We can use simple $union$ and $intersection$ operations on the top level index to locate relevant k-truss communities of a given query to answer \toplevelprob{} queries directly. Once identifiers of relevant communities are found, they can be handed to the bottom level index to processing inner-community details for \bottomlevelprob{} queries.
For example, given a community search query, we first use the top level index to find target k-truss communities that contain all query vertices and then use the bottom level index to retrieve edges contained in each target k-truss community without expensive triangle enumerations. We proved our index and query process to be theoretically optimal and showed its efficiency in practice for various kinds of \toplevelprob{} and \bottomlevelprob{} k-truss community queries on real-world graphs and demonstrate its performance by comparing with state-of-the-art methods, the TCP index \cite{huang2014querying} and the Equitruss index \cite{akbas2017truss}. For reproducibility, we make the source code available online.\footnote{https://github.com/DongCiLu/KTruss}

Our contribution can be summarized as follows.
\begin{itemize}
	\item We generalize community search problem into local community query problem. The generalization lies in three aspects. First, we introducing both \toplevelprob{} queries and \bottomlevelprob{} queries that provide different level of details for relevant communities. Second, we support multiple query vertices to enable applications that require community relation among query vertices. Third, we incorporate various cohesiveness criteria instead of a single cohesiveness measurement as used in related works.
	\item We develop a \twolevelindex{} structure that can efficiently process both the \toplevelprob{} and the \bottomlevelprob{} k-truss community query for a single query vertex or a set of query vertices with any given cohesiveness creteria with a two step process.
	\item We perform extensive experiments on our \twolevelindex{} on large-scale real-world graphs and show that our index structure outperforms state-of-the-art index structures. 
\end{itemize}

The rest of this paper is organized as follows. Section~\ref{preliminary} provides notations and definitions used in this paper. We design a novel 2-level index structure and its query process in Section~\ref{index}. The evaluations of our algorithm are in Section~\ref{evaluation}. We discuss previous works in Section~\ref{relatedwork} and conclude our work in Section~\ref{conclusion}.

