\section{Introduction}
\label{introduction}

Community structures naturally exist in many real-world networks such as social, biological, collaboration, and communication networks. The task of community detection is to identify all communities in a network, which is a fundamental and well-studied problem in the literature. Recently, several papers have studied a
related but different problem called community search, which is to find the community containing a given set of query nodes. The need for community search naturally arises in many real application scenarios, where one is motivated by the discovery of the communities in which given query nodes participate. Since the communities defined by different nodes in a network may be quite different, community search with query nodes opens up the prospects of user-centered and personalized search, with the potential of the answers being more meaningful to a user~\cite{huang2014querying}. As just one example, in a social network, the community formed by a person's high school classmates can be significantly different from the community formed by her family members which in turn can be quite different from the one formed by her colleagues~\cite{mcauley2012learning}.

Various community models have been proposed based on different dense subgraph structures such as k-core~\cite{sozio2010community, cui2014local, li2015influential}, k-truss~\cite{huang2014querying}, quasi-clique~\cite{cui2013online}, weighted densest subgraph~\cite{wu2015robust}, to name a few major examples. Of these, the k-truss as a definition of cohesive subgraph of a graph G, requires that each edge be contained in at least (k - 2) triangles within this subgraph. It is well known that most of real-world social networks are triangle-based, which always have high local clustering coefficient. Triangles are known as the fundamental building blocks of networks~\cite{wang2012truss}. In a social network, a triangle indicates two friends have a common friend, which shows a strong and stable relationship among three friends. Intuitively, the more common friends two people have, the stronger their relationship. In a k-truss, each pair of friends is "`endorsed"' by at least (k - 2) common friends. Thus, a k-truss with a large value of k signifies strong inner-connections between members of the subgraph. Huang et al.~\cite{huang2014querying} proposed a community model based on the notion of k-truss as follows. Given one query node q and a parameter k, a k-truss community containing q is a maximal k-truss containing q, in which each edge is "`triangle connected"' with other edges. Triangle connectivity is strictly stronger than connectivity. The k-truss community model works well to find all overlapping communities containing a query node q. We extended this model for the case of multiple query nodes. 

AS The time complexity of the state-of-art approximation algorithm can calculate the connected truss community containing all query vertices with the largest $k$ with a time complexity of $O(n'm')$ where $n'$ and $m'$ are the size of the result truss community. Although the linear time complexity for retrieve the whole community is optimal, these algorithms have limited scalability in large scale graphs, where communities grow to millions of edges. In many applications, such as query if a set of users are involved in same community and how cohesive is the community, only the infomation, such as the identity, the $k$ and the size, of the community are required rather than the detailed community itself. For these quries, We construct an index structure that can retrieve information of all connected k-truss communities that contain $Q$ with all possible K values. The algorithm can run in $\sum_{u \in Q} d_u$, where $d_u$ is the degree of vertex $u$. We prove that this is the optimal time complexity for truss community query. Note that if further details of found truss communities are required, our index structure can also retrieve the exact community with linear time complexity to the community size which is also the optimal time complexity.

The rest of this paper is organized as follows. In Section~\ref{relatedwork} we show previous works on community search and detection as well as dense graph mining. Section~\ref{preliminary} provides notations and definitions used in this paper. We explain induced mst graph for truss community search in Section~\ref{induced_graph}. Section~\ref{index} discusses index construction algorithm. The evaluations of our algorithm are in Section~\ref{evaluation}. We conclude our work in Section~\ref{conclusion}.
